from requests.packages.urllib3.exceptions import InsecureRequestWarning
import requests
from requests.adapters import HTTPAdapter
from requests.packages.urllib3.util.retry import Retry
from dataclasses import dataclass, field
from typing import List, Dict, Tuple
import base64
import datetime
import concurrent.futures
import logging
import netaddr
import re
import ConfigParser
import os

logger = logging.getLogger(__name__)

Config = ConfigParser.ConfigParser()
Config.read(os.path.join(os.path.abspath(os.path.dirname(__file__)),'settings.ini'))
device42_api = Config.get('Settings', 'Device42_API')
device42_user = Config.get('Settings', 'Device42_User')
device42_password = Config.get('Settings', 'Device42_Password')

MAX_THREADS = 14
requests.packages.urllib3.disable_warnings(InsecureRequestWarning)


@dataclass  # A class to contain all the necessary fields to create report
class Device:
    name: str
    os: str
    last_updated: datetime
    ip_addresses_dict: List[Dict[str, str]]
    simplified_ip_list: List[str] = field(init=False, default='')

    def __post_init__(self):
        self.simplified_ip_list = [ip['ip'] for ip in self.ip_addresses_dict if ip]


# Generate session with max of 3 retries and interval of 1 second
def session_generator(username: str, password: str) -> requests.sessions.Session:
    session = requests.Session()
    session.headers.update({'Content-Type': 'application/json', 'Authorization': 'Basic %s' % base64.b64encode(bytes("%s:%s" % (username, password), 'utf-8')).decode(encoding='UTF-8')})
    retry = Retry(connect=3, backoff_factor=0.5)
    adapter = HTTPAdapter(max_retries=retry)
    session.mount('http://', adapter)
    session.mount('https://', adapter)
    return session


def get_all_devices(username: str, password: str, offset: int = 0) -> Tuple[int, List[Device]]:
    total_devices = 0
    devices = []
    params = {'include_cols': 'name,ip_addresses,os,last_updated,osver', 'offset': offset, 'limit': 1000}
    session = session_generator(username, password)
    url = '%s/devices/all/' % device42_api
    resp = session.get(url, params=params, verify=False)
    response = resp.json()
    if resp.ok:
        total_devices = response['total_count']
        for device in response['Devices']:
            if device['ip_addresses']:
                os = device['os']
                if device['osver']:
                    os = "%s release %s" % (os, device['osver'])
                deviceobj = Device(
                    device['name'].lower(),
                    os,
                    datetime.datetime.strptime(device['last_updated'].split('.')[0], '%Y-%m-%dT%H:%M:%S'),
                    device['ip_addresses']
                )
                devices.append(deviceobj)
    else:
        logger.error("ERROR %s: %s" % (resp.status_code, response))
    return total_devices, devices


def get_all_subnets(username: str, password: str) -> Tuple[List[netaddr.IPAddress], List[netaddr.IPAddress]]:
    secure_zone = []
    dmz_zone = []
    session = session_generator(username, password)
    url = '%s/subnets/' % device42_api
    total = 0
    offset = 0
    limit = 0
    while True:
        params = {'include_cols': 'name,range_begin,range_end', 'offset': offset}
        resp = session.get(url, params=params, verify=False)
        response = resp.json()
        if resp.ok:
            if 'total_count' in response:
                total = response['total_count']
            if 'offset' in response:
                offset = response['offset']
            if 'limit' in response:
                limit = response['limit']
            for subnet in response['subnets']:
                """
                Define the zones as seen in your company
                """
                if re.search(r'.*Secure.*', subnet['name'], flags=re.I):
                    start = subnet['range_begin']
                    end = subnet['range_end']
                    secure_zone.extend(list(netaddr.IPRange(start, end)))
                elif re.search(r'.*DMZ.*', subnet['name'], flags=re.I):
                    start = subnet['range_begin']
                    end = subnet['range_end']
                    dmz_zone.extend(list(netaddr.IPRange(start, end)))
            if total - offset - limit > 0:
                offset = offset + 1000
            else:
                break
        else:
            logger.error("ERROR %s: %s" % (resp.status_code, response))
    return secure_zone, dmz_zone


def fetch_device_info() -> List[Device]:
    devices = []
    logger.info("Fetching all devices")
    total_devices, initial_device_list = get_all_devices(device42_user, device42_password)
    if total_devices > 0:
        logger.info('Total number of initial devices found: %d' % total_devices)
        devices.extend(initial_device_list)
    else:
        logger.error('Unable to fetch any devices from Device42')
    if total_devices > 1000:
        offsets = [offset for offset in range(1001, total_devices + 1, 1000)]
        with concurrent.futures.ThreadPoolExecutor(max_workers=MAX_THREADS) as executor:
            fs = [executor.submit(get_all_devices, device42_user, device42_password, offset) for offset in offsets]
            for future in concurrent.futures.as_completed(fs):
                _, device_list = future.result()
                if device_list:
                    devices.extend(device_list)

    logger.info('Total number of final devices that have ip:  %d' % len(devices))
    return devices


def fetch_security_zones_ips() -> Tuple[List[netaddr.IPAddress], List[netaddr.IPAddress]]:
    logger.info("Fetching all security zones")
    secure_zone, dmz_zone = get_all_subnets(device42_user, device42_password)
    secure_zone = list(set([str(ip) for ip in secure_zone]))
    dmz_zone = list(set([str(ip) for ip in dmz_zone]))
    logger.info('Total number of IPs in secure zone: %d' % len(secure_zone))
    logger.info('Total number of IPs in dmz zone: %d' % len(dmz_zone))
    return secure_zone, dmz_zone
