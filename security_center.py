from requests.packages.urllib3.exceptions import InsecureRequestWarning
import requests
from requests.adapters import HTTPAdapter
from requests.packages.urllib3.util.retry import Retry
from dataclasses import dataclass, field
from typing import List, Tuple, Dict
import datetime
import logging
import re
import concurrent.futures
import device42
import netaddr
import ConfigParser
import os

logging.basicConfig(level=logging.INFO, format='%(asctime)s %(name)-15s [%(levelname)-8s]: %(message)s', datefmt='%m/%d/%Y %I:%M:%S %p')
logger = logging.getLogger(__name__)
MAX_THREADS = 14  # Get max number of threads for multi-threading

Config = ConfigParser.ConfigParser()
Config.read(os.path.join(os.path.abspath(os.path.dirname(__file__)),'settings.ini'))
security_centre_api = Config.get('Settings', 'Nessus_Security_Center_API')
security_centre_user = Config.get('Settings', 'Nessus_Security_Center_User')
security_centre_secret = Config.get('Settings', 'Nessus_Security_Center_Secret')
requests.packages.urllib3.disable_warnings(InsecureRequestWarning)


@dataclass  # A class to contain all the necessary fields to create report
class Vulnerability:
    plugin_name: str
    family: str
    severity: str
    dns: str
    ip: str
    nessus_repository: str
    date_first_seen_in_environment: datetime
    exploit_available: bool
    patch_available_date: bool
    cvss_base_score: float
    cvss_temporal_score: float
    cves: List[str]
    resolution: str
    additional_links: List[str]
    netbios: str
    zone: str = field(init=False, default='')  # Critical/Non-critical Asset
    vulnerability_type: str = field(init=False, default='')
    platform: str = field(init=False, default='')
    nessus_criticiality: str = field(init=False, default='')
    actual_criticality: str = field(init=False, default='')
    host_risk: str = field(init=False, default='')
    environment: str = field(init=False, default='')
    os: str = field(init=False, default='')

    def __post_init__(self):
        self.nessus_criticiality_insight()
        self.get_type()

    def guess_platform(self):
        if 'Windows' in self.family or 'Microsoft' in self.plugin_name or 'Windows' in self.plugin_name:
            self.platform = 'Windows'
        elif 'Windows' in self.resolution or ' GP' in self.resolution or 'Group Policy' in self.resolution:
            self.platform = 'Windows'
        else:
            self.platform = 'Linux'

    def platform_based_on_os(self):
        if 'window' in self.os.lower():
            self.platform = 'Windows'
        else:
            self.platform = 'Linux'

    def get_type(self):
        self.vulnerability_type = 'config'
        if self.nessus_repository == 'Configuration Audits':
            self.vulnerability_type = 'config'
        elif self.family == 'Windows : Microsoft Bulletins':
            self.vulnerability_type = 'package'
        elif 'update ' in self.resolution.lower() or 'CentOS Update Set' in self.plugin_name or 'upgrade ' in self.resolution.lower() or 'MS KB' in self.plugin_name:
            self.vulnerability_type = 'package'
        elif 'Apply the client registry key workaround and the server registry key workaround suggested by Microsoft in the advisory.' == self.resolution:
            self.vulnerability_type = 'config'
        elif re.search('.* KB\d{3,} .*', self.resolution, flags=re.I) or 'patch' in self.resolution:
            self.vulnerability_type = 'package'

    def modify_solution(self):
        if self.vulnerability_type == 'package' and self.platform == 'Windows':
            if 'Microsoft has released the following security updates to address this issue:' in self.resolution or 'Apply the following security updates ' in self.resolution or 'Apply Service Stack ' in self.resolution or 'Microsoft has released KB' in self.resolution or 'Install Microsoft KB' in self.resolution:
                get_security_kb = re.findall(r"KB\d{4,}", self.resolution, flags=re.IGNORECASE)
                if not get_security_kb:
                    get_security_kb = re.findall(r"\d{4,}", self.resolution, flags=re.IGNORECASE)
                    get_security_kb = ["KB%s" % security_kb for security_kb in get_security_kb]
                if get_security_kb:
                    self.resolution = ','.join(get_security_kb).replace("'", '').replace('"', '').replace(' ', '')

            elif 'Apply '.lower() in self.resolution.lower():
                #
                get_security_kb = re.findall(r".*Security .* (KB\d{4,}) or Cumulative.*", self.resolution, flags=re.IGNORECASE)
                if not get_security_kb:
                    # Apply security update KB4022715 as well as refer to the KB article for additional information
                    get_security_kb = re.findall(r".*Security .* (KB\d{4,})", self.resolution, flags=re.IGNORECASE)

                if not get_security_kb:
                    # Apply Cumulative Update KB4056890 or KB4057142 as well as || Apply Cumulative Update KB4493509 *
                    get_security_kb = re.findall(r".*Cumulative .* (KB\d{4,})", self.resolution, flags=re.IGNORECASE)
                '''
                if not get_security_kb:
                    # Apply security update KB4023307.
                    get_security_kb = re.findall(r".*Security .* (KB\d{4,})", self.resolution, flags=re.IGNORECASE)
                '''
                if get_security_kb:
                    self.resolution = ','.join(get_security_kb).replace("'", '').replace('"', '').replace(' ', '')

            elif 'MS' in self.plugin_name and 'KB' not in self.resolution:
                get_security_bulletin_number = re.findall(r"^MS\d{2,}-\d{3,}", self.plugin_name, flags=re.IGNORECASE)
                if len(get_security_bulletin_number) == 1:
                    year = get_security_bulletin_number[0].split('-')[0].replace('MS', '')
                    link = "https://docs.microsoft.com/en-us/security-updates/SecurityBulletins/20%s/%s" % (year, get_security_bulletin_number[0].lower())
                    self.resolution = link
            elif 'ADV' in self.plugin_name and ' KB' not in self.resolution:
                get_ADV = re.findall(r"^ADV\d{4,}", self.plugin_name, flags=re.IGNORECASE)
                if len(get_ADV) == 1:
                    ADV = get_ADV[0].split(':')[0]
                    link = "https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/%s" % ADV.upper()
                    self.resolution = link
            elif ('Microsoft has released a set of ' in self.resolution or 'Apply the appropriate patches according to the' in self.resolution or 'Microsoft has released security updates for ' in self.resolution):
                self.resolution = self.additional_links[0]

        elif self.vulnerability_type == 'package' and self.platform == 'Linux':
            """
                Modify Linux Solution that you want in the report as per your Linux box
            """
            if 'Update ' in self.resolution:
                self.resolution = 'yum update '
                for cve in self.cves:
                    self.resolution = '%s --cve %s ' % (self.resolution, cve)

    def nessus_criticiality_insight(self):
        if self.exploit_available:
            if self.cvss_temporal_score > 0.0:
                if self.cvss_temporal_score > 6.9:
                    self.nessus_criticiality = 'High'
                elif self.cvss_temporal_score > 3.9:
                    self.nessus_criticiality = 'Medium'
                else:
                    self.nessus_criticiality = 'Low'
            elif self.cvss_base_score > 0.0:
                if self.cvss_base_score > 6.9:
                    self.nessus_criticiality = 'High'
                elif self.cvss_base_score > 3.9:
                    self.nessus_criticiality = 'Medium'
                else:
                    self.nessus_criticiality = 'Low'
        else:
            if self.cvss_temporal_score > 0.0:
                if self.cvss_temporal_score > 6.9:
                    self.nessus_criticiality = 'Medium'
                elif self.cvss_temporal_score > 3.9:
                    self.nessus_criticiality = 'Medium'
                else:
                    self.nessus_criticiality = 'Low'
            elif self.cvss_base_score > 0.0:
                if self.cvss_base_score > 6.9:
                    self.nessus_criticiality = 'Medium'
                elif self.cvss_base_score > 3.9:
                    self.nessus_criticiality = 'Medium'
                else:
                    self.nessus_criticiality = 'Low'

    def get_host_risk(self):
        """
                Use a combination of host dns (self.dns) and the zone that host is in to define host risk

                For example:
                haproxy_box = re.search('.*haproxy.*', self.dns, flags=re.IGNORECASE)
                web_box = re.search('.*web.*', self.dns, flags=re.IGNORECASE)
                app_box = re.search('.*app.*', self.dns, flags=re.IGNORECASE)
                proxy_box = re.search('^proxy.*', self.dns, flags=re.IGNORECASE)

                if self.zone == 'DMZ':
                    if self.platform == 'Linux':
                        if web_box or haproxy_box:
                            self.host_risk = 'High'
                        elif app_box:
                            self.host_risk = 'Medium'

                elif self.zone == 'Secure':
                    if self.platform == 'Linux':
                        if app_box:
                            self.host_risk = 'High'
                        elif proxy_box:
                            self.host_risk = 'Medium'
        """

    def actual_criticality_insight(self):
        if self.host_risk == 'High':
            if self.nessus_criticiality == 'Low':
                self.actual_criticality = 'Medium'
            elif self.nessus_criticiality == 'Medium':
                self.actual_criticality = 'High'
            elif self.nessus_criticiality == 'High':
                self.actual_criticality = 'High'
        elif self.host_risk == 'Medium':
            if self.nessus_criticiality == 'Low':
                self.actual_criticality = 'Medium'
            elif self.nessus_criticiality == 'Medium':
                self.actual_criticality = 'Medium'
            elif self.nessus_criticiality == 'High':
                self.actual_criticality = 'High'
        elif self.host_risk == 'Low':
            if self.nessus_criticiality == 'Low':
                self.actual_criticality = 'Low'
            elif self.nessus_criticiality == 'Medium':
                self.actual_criticality = 'Low'
            elif self.nessus_criticiality == 'High':
                self.actual_criticality = 'Medium'
        else:
            self.actual_criticality = 'Unknown'


# Generate session with max of 3 retries and interval of 1 second
def session_generator(token: str, cookie: requests.cookies.RequestsCookieJar) -> requests.sessions.Session:
    session = requests.Session()
    session.headers.update({'Content-Type': 'application/json', 'X-SecurityCenter': token})
    retry = Retry(connect=3, backoff_factor=0.5)
    adapter = HTTPAdapter(max_retries=retry)
    session.mount('http://', adapter)
    session.mount('https://', adapter)
    session.cookies = cookie
    return session


def validate_security_center() -> bool:
    resp = requests.get("%s/system" % security_centre_api, verify=False)
    if resp.ok:
        return True
    return False


def create_token() -> Tuple[str, requests.cookies.RequestsCookieJar]:
    data = {'username': security_centre_user, 'password': security_centre_secret}
    resp = requests.post("%s/token" % security_centre_api, json=data, verify=False)
    response = resp.json()
    token = str(response['response']['token']) or None
    cookie = resp.cookies
    if resp.ok:
        if 'releaseSession' in response and response['releaseSession']:
            logger.critical('Maximum login limit reached.')
        else:
            logger.info('Session token created')
    else:
        logger.error('Unable to create token for user')
        logger.error('Security Centre Error %d:%s' % (response['error_code'], response['error_msg']))
    return token, cookie


def parse_vulnerability_details(detail: Dict) -> Vulnerability:
    #if detail['netbiosName'] and not detail['dnsName']:
    #    detail['netbiosName'] = re.findall(r"\w*\\*(.*)", detail['netbiosName'], re.IGNORECASE)[0].lower()

    if detail['exploitAvailable'] == "Yes":
        exploit_available = True
    else:
        exploit_available = False

    if detail['patchPubDate']:
        patch_available = True
    else:
        patch_available = False

    if detail['cve']:
        if ',' in detail['cve']:
            cves = detail['cve'].split(',')
        else:
            cves = [detail['cve']]
    else:
        cves = []

    # Search for solution in the plugin text
    if not detail['solution'] and '<' in detail['pluginText'] and '</' in detail['pluginText']:
        searchobj = re.search(r"^<.*solution>(.*)</.*solution>", detail['pluginText'].replace('\n', ''), flags=re.IGNORECASE)
        if searchobj:
            detail['solution'] = searchobj.group(1)

    if detail['seeAlso']:
        additional_links = [detail['seeAlso'].splitlines()[0]]
    else:
        additional_links = []

    vulnobj = Vulnerability(
        detail['pluginName'],
        detail['family']['name'],
        detail['severity']['name'],
        detail['dnsName'].lower(),
        detail['ip'],
        detail['repository']['name'],
        datetime.datetime.utcfromtimestamp(int(detail['firstSeen'])),
        exploit_available,
        patch_available,
        float(detail['baseScore'] or "0.0"),
        float(detail['temporalScore'] or "0.0"),
        cves,
        detail['solution'].replace('\r', '').replace('\n', ' '),
        additional_links,
        detail['netbiosName']
    )

    return vulnobj


def get_vulnerability_list(session_contents: Dict[str, requests.cookies.RequestsCookieJar], startOffset: int = 0, endOffset: int = 1000) -> Tuple[int, List[Vulnerability]]:
    vulnerabilities = []
    total_records = 0
    data = {
        'type': 'vuln',
        'query': {
            'type': 'vuln',
            'sortField': 'severity',
            'sortDir': 'DESC',
            'startOffset': startOffset,
            'endOffset': endOffset,
            'tool': 'vulndetails',
            'filters': [
                {
                    'filterName': 'severity',
                    'operator': '=',
                    'value': '1,2,3,4'  # Low to Critical Severity
                },
                {
                    'filterName': 'lastSeen',
                    'operator': '=',
                    'value': '0:15'  # Last Seen in the past 15 days
                },
                {
                    'filterName': 'acceptRiskStatus',
                    'operator': '=',
                    'value': 'nonAccepted'
                }
            ]

        },
        'sourceType': 'cumulative'

    }
    session = session_generator(session_contents['token'], session_contents['cookie'])
    resp = session.post("%s/analysis" % security_centre_api, json=data, verify=False)
    response = resp.json()
    if not resp.ok:
        logger.error('Unable to get vulnerabilty list for servers')
        logger.error('Security Centre Error %d:%s' % (response['error_code'], response['error_msg']))

    else:
        response = response['response']
        total_records = int(response['totalRecords']) or 0

        with concurrent.futures.ThreadPoolExecutor(max_workers=2) as executor:
            fs = [executor.submit(parse_vulnerability_details, detail) for detail in response['results']]
            for future in concurrent.futures.as_completed(fs):
                vulnerabilities.append(future.result())
    session.close()
    return total_records, vulnerabilities


def delete_token(session_contents: Dict[str, requests.cookies.RequestsCookieJar]) -> None:
    session = session_generator(session_contents['token'], session_contents['cookie'])
    resp = session.delete("%s/token" % security_centre_api, verify=False)
    response = resp.json()
    if not resp.ok:
        logger.error('Unable to delete token for user')
        logger.error('Security Centre Error %d:%s' % (response['error_code'], response['error_msg']))
    else:
        logger.info('Session token deleted')
    session.close()


def get_zone(iplist: List[str], secure_zone: List[netaddr.IPAddress], dmz_zone: List[netaddr.IPAddress]) -> Dict[str, str]:
    logging.info('Mapping IP to Zone')
    ip_zone = {}

    for ip in iplist:
        if ip in dmz_zone:
            ip_zone[ip] = 'DMZ'
        elif ip in secure_zone:
            ip_zone[ip] = 'Secure'
    return ip_zone


def check_ip_in_device42(ip: str, all_servers: List[device42.Device]) -> Dict[str, str]:
    last_updated_time = None
    hostname = None
    for device in all_servers:
        if ip in device.simplified_ip_list and (last_updated_time is None or (device.last_updated > last_updated_time)):
            hostname = device.name
            last_updated_time = device.last_updated
    return {ip: hostname}


def get_rerouted_url(link):
    link_dict = {}
    resp = requests.get(link)
    link_dict[link] = resp.url
    return link_dict


def fetch_vulnerabilities() -> List[Vulnerability]:
    vulnerabilities_list = []
    if validate_security_center():
        session_contents = {}
        token, cookie = create_token()
        if token is not None:
            session_contents['token'] = token
            session_contents['cookie'] = cookie
        else:
            logger.critical('Exiting')
            exit(-1)

        logger.info('Fetching all vulnerabilities from Nessus')
        total_vulnerabilities, vulnerabilities = get_vulnerability_list(session_contents)
        logger.info('Found %d vulnerabilities' % total_vulnerabilities)
        vulnerabilities_list.extend(vulnerabilities)

        if total_vulnerabilities != 0:
            list_of_start_offsets = [(startOffset, startOffset + 5000) for startOffset in
                                     range(1000, total_vulnerabilities, 5000)]
            with concurrent.futures.ThreadPoolExecutor(max_workers=MAX_THREADS) as executor:
                fs = [executor.submit(get_vulnerability_list, session_contents, startOffset=offset[0],
                                      endOffset=offset[1]) for offset in list_of_start_offsets]
                for future in concurrent.futures.as_completed(fs):
                    _, vulnerabilities = future.result()
                    vulnerabilities_list.extend(vulnerabilities)
        logger.info('Fetched all vulnerabilities')

        delete_token(session_contents)

        vulnerable_ips = list(set([vulnerability.ip for vulnerability in vulnerabilities_list]))
        logger.info('Total number of IPs: %d' % len(vulnerable_ips))
        secure_zone, dmz_zone = device42.fetch_security_zones_ips()
        ip_zone_mapping = get_zone(vulnerable_ips, secure_zone, dmz_zone)
        vulnerable_ips.clear()

        logging.info('Assigning zone to each vulnerability')
        for vulnerability in vulnerabilities_list:
            if vulnerability.ip in ip_zone_mapping:
                vulnerability.zone = ip_zone_mapping[vulnerability.ip]

        ip_with_no_zone = list(set([vulnerability.ip for vulnerability in vulnerabilities_list if not vulnerability.zone]))
        logger.info('IPs with no zone: %d' % len(ip_with_no_zone))
        ip_with_no_zone.clear()

        all_devices = device42.fetch_device_info()
        device42_os_device_mapping = {device.name: device.os for device in all_devices if device.name and device.os}

        logger.info('Mapping hostname to os against Device42')
        for vulnerability in vulnerabilities_list:
            if vulnerability.dns and vulnerability.dns in device42_os_device_mapping:
                vulnerability.os = device42_os_device_mapping[vulnerability.dns]

        vulnerable_ips_with_no_dns = list(set([vulnerability.ip for vulnerability in vulnerabilities_list if not vulnerability.dns]))
        logger.info('Found %d IPs with no domain name' % len(vulnerable_ips_with_no_dns))
        if vulnerable_ips_with_no_dns:
            logger.info('Checking those IPs against Device42')
            ip_to_device_mapping = {}
            with concurrent.futures.ThreadPoolExecutor(max_workers=MAX_THREADS) as executor:
                fs = [executor.submit(check_ip_in_device42, ip, all_devices) for ip in vulnerable_ips_with_no_dns]
                for future in concurrent.futures.as_completed(fs):
                    ip_to_device_mapping.update(future.result())
            all_devices.clear()
            vulnerable_ips_with_no_dns.clear()
            logger.info('Updating those IPs')
            for vulnerability in vulnerabilities_list:
                if vulnerability.ip in ip_to_device_mapping and ip_to_device_mapping[vulnerability.ip] is not None:
                    if ip_to_device_mapping[vulnerability.ip] in device42_os_device_mapping:
                        vulnerability.os = device42_os_device_mapping[ip_to_device_mapping[vulnerability.ip]]
                    vulnerability.dns = ip_to_device_mapping[vulnerability.ip]

            logger.info('Updating leftover hostname from netbios and rechecking device42 from the updated netbios')
            for vulnerability in vulnerabilities_list:
                if not vulnerability.dns and vulnerability.netbios:
                    #vulnerability.dns = vulnerability.netbios
                    for device in device42_os_device_mapping:
                        if vulnerability.netbios.split('\\')[1].lower() in device:
                            vulnerability.os = device42_os_device_mapping[device]
                            break
        device42_os_device_mapping.clear()
        '''
        logger.info('Matching IPs with Service Now for all vulnerability')
        active_servers = snow.fetch_categorized_servers()
        if active_servers:
            for vulnerability in vulnerabilities_list:
                if not vulnerability.platform and vulnerability.ip in active_servers:
                    if 'Windows' in active_servers[vulnerability.ip][0]:
                        vulnerability.platform = 'Windows'
                    else:
                        vulnerability.platform = 'Linux'
                if not vulnerability.dns and vulnerability.ip in active_servers:
                    vulnerability.dns = active_servers[vulnerability.ip][1]
        '''

        '''
        logger.info('Collecting device info for leftover assets')
        assets = []
        ips = [vulnerability.ip for vulnerability in vulnerabilities_list if not vulnerability.dns]
        if ips:
            with concurrent.futures.ThreadPoolExecutor(max_workers=10) as executor:
                fs = [executor.submit(get_device_info, session_contents, ip) for ip in ips]
                for future in concurrent.futures.as_completed(fs):
                    if future.result() is not None:
                       assets.append(future.result())

        delete_token(session_contents)

        assets_ip_os = {asset.ip: asset.os for asset in assets}
        assets_ip_dns = {asset.ip: asset.dns for asset in assets}
        for vulnerability in vulnerabilities_list:
            if not vulnerability.platform and vulnerability.ip in assets_ip_os and assets_ip_os[vulnerability.ip]:
                if 'Windows' in assets_ip_os[vulnerability.ip]:
                    vulnerability.platform = 'Windows'
                else:
                    vulnerability.platform = 'Linux'

            if not vulnerability.dns and vulnerability.ip in assets_ip_dns and assets_ip_dns[vulnerability.ip]:
                vulnerability.dns = assets_ip_dns[vulnerability.ip]
        '''

        vulnerable_ips_with_no_os = {vulnerability.ip: vulnerability.dns for vulnerability in vulnerabilities_list if not vulnerability.os}

        logger.info('Leftover IPs not present in Device42: %d' % len(vulnerable_ips_with_no_os))
        if vulnerable_ips_with_no_os:
            logger.info('Leftover IPs that do not have a hostname: %d' % len([ip for ip in vulnerable_ips_with_no_os if not vulnerable_ips_with_no_os[ip]]))
            vulnerable_ips_with_no_os.clear()
            logger.info('Guessing OS for these leftover IPs')
            for vulnerability in vulnerabilities_list:
                if not vulnerability.os:
                    vulnerability.guess_platform()

        logging.info('Enriching platform for each host')
        for vulnerability in vulnerabilities_list:
            if not vulnerability.platform:
                vulnerability.platform_based_on_os()

        logging.info('Getting asset risk for each vulnerability')
        for vulnerability in vulnerabilities_list:
            if vulnerability.zone and vulnerability.dns:
                vulnerability.get_host_risk()
        
        logging.info('Assigning vulnerability_rating for each vulnerability')
        for vulnerability in vulnerabilities_list:
            if vulnerability.host_risk and vulnerability.nessus_criticiality:
                vulnerability.actual_criticality_insight()

        logger.info('Modifing solution for vulnerabilities')
        for vulnerability in vulnerabilities_list:
            if vulnerability.vulnerability_type == 'package':
                vulnerability.modify_solution()

        logger.info('Mapping info links to rerouted link')
        links = []
        for vulnerability in vulnerabilities:
            links.extend(vulnerability.additional_links)
        links = list(set(links))
        map_link_to_its_rerouted_url = {}

        with concurrent.futures.ThreadPoolExecutor(max_workers=1000) as executor:
            for link_dict in executor.map(get_rerouted_url, links):
                map_link_to_its_rerouted_url.update(link_dict)

        for vulnerability in vulnerabilities_list:
            temp_links_holder = []
            for link in vulnerability.additional_links:
                if link in map_link_to_its_rerouted_url:
                    temp_links_holder.append(map_link_to_its_rerouted_url[link])
            vulnerability.additional_links = temp_links_holder

    return vulnerabilities_list
