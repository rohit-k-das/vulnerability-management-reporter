import requests
from requests.adapters import HTTPAdapter
from requests.packages.urllib3.util.retry import Retry
import json
import logging
import time
import jwt
from typing import Tuple
import ConfigParser
import os

MAX_THREADS = 14  # Get max number of threads for multi-threading

logging.basicConfig(level=logging.INFO, format='%(asctime)s %(name)-15s [%(levelname)-8s]: %(message)s',
                        datefmt='%m/%d/%Y %I:%M:%S %p')
logger = logging.getLogger(__name__)

Config = ConfigParser.ConfigParser()
Config.read(os.path.join(os.path.abspath(os.path.dirname(__file__)), 'settings.ini'))
google_service_account_secret = Config.get('Settings', 'Google_Service_Account_Secret')
google_service_account_id = Config.get('Settings', 'Google_Service_Account_ID')


drive_api = 'https://www.googleapis.com/drive/v3/{0}'
drive_access_tokens = {}


# Generate session with max of 3 retries and interval of 1 second
def session_generator():
    session = requests.Session()
    retry = Retry(connect=3, backoff_factor=0.5)
    adapter = HTTPAdapter(max_retries=retry)
    session.mount('http://', adapter)
    session.mount('https://', adapter)
    return session


# Create OAuth token per requirement for each recipient
def generate_drive_api_access_token(recipient: str) -> Tuple[str, int]:
    access_token = None
    expiry = None
    jwt_header = {"alg": "RS256", "typ": "JWT"}
    iat = time.time()
    exp = iat + 3600
    jwt_claim_set = {
        'iss': google_service_account_id,
        'scope': 'https://www.googleapis.com/auth/drive.file https://www.googleapis.com/auth/drive.appdata https://www.googleapis.com/auth/drive.readonly',
        'sub': recipient,
        'aud': 'https://www.googleapis.com/oauth2/v4/token',
        'iat': iat,
        'exp': exp
    }
    secret = bytes(google_service_account_secret.replace('\\n', '\n'), 'utf-8')
    signed_jwt = jwt.encode(jwt_claim_set, secret, headers=jwt_header, algorithm='RS256')
    headers = {"Content-Type": "application/json; charset=utf-8"}
    data = {'grant_type': 'urn:ietf:params:oauth:grant-type:jwt-bearer', 'assertion': signed_jwt.decode('utf-8').replace("'", '"')}
    url = 'https://www.googleapis.com/oauth2/v4/token'
    session = session_generator()
    resp = session.post(url, headers=headers, data=json.dumps(data))
    response = resp.json()
    if resp.ok:
        access_token = response['access_token']
        expiry = time.time() + response['expires_in']
    elif resp.status_code == 429:
        logger.error('Too many requests. Sleeping %s' % response['error_description'])
        time.sleep(1)
        access_token, expiry = generate_drive_api_access_token(recipient)
    else:
        logger.error('Failed to generate access token')
        logger.error("%d:%s" % (resp.status_code, resp.text))
    return access_token, expiry


def find_drive(drive_name: str, recipient: str) -> str:
    drive_id = None
    access_token = drive_access_tokens[recipient]['access_token']
    expiry = drive_access_tokens[recipient]['expiry']
    query_start_time = time.time()

    # Make the API call if token expiry time is greater than 1 minute
    if (expiry - query_start_time) > 60:
        headers = {'Content-Type': 'application/json', 'Authorization': 'Bearer %s' % access_token}
        url = drive_api.format("drives")
        session = session_generator()
        resp = session.get(url, headers=headers)
        if resp.ok:
            response = resp.json()
            for drive in response['drives']:
                if drive['kind'] == 'drive#drive' and drive['name'] == drive_name:
                    drive_id = drive['id']
        # Rate limiting
        elif resp.status_code == 429:
            logger.error('Too many requests. Sleeping %s' % resp.json()['error']['message'])
            time.sleep(1)
            drive_id = find_drive(drive_name, recipient)
        else:
            logger.error('Failed to create folder')
            logger.error("%d:%s" % (resp.status_code, resp.text))
    # Create new access token to be used by the recipient
    else:
        access_token, expiry = generate_drive_api_access_token(recipient)
        if access_token is not None and expiry is not None:
            drive_access_tokens[recipient]['access_token'] = access_token
            drive_access_tokens[recipient]['expiry'] = expiry
            drive_id = find_drive(drive_name, recipient)
    return drive_id


def find_folder(folder_name: str, recipient: str, driveId: str, parent_folder_id: str = None):
    folder_id = None
    access_token = drive_access_tokens[recipient]['access_token']
    expiry = drive_access_tokens[recipient]['expiry']
    query_start_time = time.time()

    # Make the API call if token expiry time is greater than 1 minute
    if (expiry - query_start_time) > 60:
        headers = {'Content-Type': 'application/json', 'Authorization': 'Bearer %s' % access_token}
        params = {
            'corpora': 'drive',
            'includeItemsFromAllDrives': True,
            'supportsAllDrives': True,
            'driveId': driveId,
            'fields': 'incompleteSearch,files(id,name,mimeType,parents)'
        }

        if parent_folder_id is None:
            params['q'] = "mimeType = 'application/vnd.google-apps.folder' and name = '%s' and trashed = false" % folder_name
        else:
            params['q'] = "mimeType = 'application/vnd.google-apps.folder' and name = '%s' and '%s' in parents and trashed = false" % (folder_name, parent_folder_id)
        url = drive_api.format("files")
        session = session_generator()
        resp = session.get(url, headers=headers, params=params)
        if resp.ok:
            response = resp.json()
            if response['incompleteSearch']:
                logger.warning('All files/folders are not returned.')
            if response['files']:
                if len(response['files']) == 1:
                    folder_id = response['files'][0]['id']
                else:
                    for file in response['files']:
                        print(file['name'], ':', file['id'])

        # Rate limiting
        elif resp.status_code == 429:
            logger.error('Too many requests. Sleeping %s' % resp.json()['error']['message'])
            time.sleep(1)
            folder_id = find_folder(folder_name, recipient, driveId)
        else:
            logger.error('Failed to create folder')
            logger.error("%d:%s" % (resp.status_code, resp.text))
    # Create new access token to be used by the recipient
    else:
        access_token, expiry = generate_drive_api_access_token(recipient)
        if access_token is not None and expiry is not None:
            drive_access_tokens[recipient]['access_token'] = access_token
            drive_access_tokens[recipient]['expiry'] = expiry
            folder_id = find_folder(folder_name, recipient, driveId)
    return folder_id


def create_folder(filename, recipient, parent_folder_id, drive_id):
    folder_id = None
    access_token = drive_access_tokens[recipient]['access_token']
    expiry = drive_access_tokens[recipient]['expiry']
    query_start_time = time.time()

    # Make the API call if token expiry time is greater than 1 minute
    if (expiry - query_start_time) > 60:
        headers = {'Content-Type': 'application/json', 'Authorization': 'Bearer %s' % access_token}
        file_metadata = {
            'name': filename,
            'mimeType': 'application/vnd.google-apps.folder',
            'parents': [parent_folder_id],
            'driveId': drive_id
        }
        url = drive_api.format("files")
        session = session_generator()
        resp = session.post(url, headers=headers, json=file_metadata, params={'supportsAllDrives': True})
        if resp.ok:
            response = resp.json()
            if 'id' in response and response['id']:
                folder_id = response['id']
        # Rate limiting
        elif resp.status_code == 429:
            logger.error('Too many requests. Sleeping %s' % resp.json()['error']['message'])
            time.sleep(1)
            folder_id = create_folder(filename, recipient, parent_folder_id)
        else:
            logger.error('Failed to create folder')
            logger.error("%d:%s" % (resp.status_code, resp.text))
    # Create new access token to be used by the recipient
    else:
        access_token, expiry = generate_drive_api_access_token(recipient)
        if access_token is not None and expiry is not None:
            drive_access_tokens[recipient]['access_token'] = access_token
            drive_access_tokens[recipient]['expiry'] = expiry
            folder_id =create_folder(filename, recipient, parent_folder_id)
    return folder_id


def create_file(parent_folder_id, filename, file_type, recipient, drive_id):
    file_id = None
    data = {
        'name': filename,
        'mimeType': file_type,
        'parents': [parent_folder_id],
        'driveId': drive_id,
    }
    params = {'supportsAllDrives': True, 'fields': 'id'}
    access_token = drive_access_tokens[recipient]['access_token']
    expiry = drive_access_tokens[recipient]['expiry']
    query_start_time = time.time()

    # Make the API call if token expiry time is greater than 1 minute
    if (expiry - query_start_time) > 60:
        headers = {'Content-Type': 'application/json', 'Authorization': 'Bearer %s' % access_token}
        url = drive_api.format("files")
        session = session_generator()
        resp = session.post(url, headers=headers, json=data, params=params)
        if resp.ok:
            response = resp.json()
            file_id = response['id']
        # Rate limiting
        elif resp.status_code == 429:
            logger.error('Too many requests. Sleeping %s' % resp.json()['error']['message'])
            time.sleep(1)
            file_id = create_file(parent_folder_id, filename, file_type, recipient, drive_id)
        else:
            logger.error('Failed to create folder %s' % filename)
            logger.error("%d:%s" % (resp.status_code, resp.text))
    # Create new access token to be used by the recipient
    else:
        access_token, expiry = generate_drive_api_access_token(recipient)
        if access_token is not None and expiry is not None:
            drive_access_tokens[recipient]['access_token'] = access_token
            drive_access_tokens[recipient]['expiry'] = expiry
            file_id = create_file(parent_folder_id, filename, file_type, recipient, drive_id)
    return file_id


def assign_permission(file_id, email, recipient):
    data = {
        'role': 'reader',
        'type': 'user',
        'emailAddress': email
    }
    message = """Hey Guys,
    This is a freshly generated vulnerability report this month. Please use this as a base for patching.
    
    - Security
    """
    params = {
        'emailMessage': message,
        'supportsAllDrives': True,
        'sendNotificationEmail': True
    }
    access_token = drive_access_tokens[recipient]['access_token']
    expiry = drive_access_tokens[recipient]['expiry']
    query_start_time = time.time()

    # Make the API call if token expiry time is greater than 1 minute
    if (expiry - query_start_time) > 60:
        headers = {'Content-Type': 'application/json', 'Authorization': 'Bearer %s' % access_token}
        url = drive_api.format("files/%s/permissions" % file_id)
        session = session_generator()
        resp = session.post(url, headers=headers, json=data, params=params)
        if resp.ok:
            logger.info('Permissions assigned to file %s successfully' % file_id)
        # Rate limiting
        elif resp.status_code == 429:
            logger.error('Too many requests. Sleeping %s' % resp.json()['error']['message'])
            time.sleep(1)

        else:
            logger.error('Failed to assign permissions to file %s' % file_id)
            logger.error("%d:%s" % (resp.status_code, resp.text))
    # Create new access token to be used by the recipient
    else:
        access_token, expiry = generate_drive_api_access_token(recipient)
        if access_token is not None and expiry is not None:
            drive_access_tokens[recipient]['access_token'] = access_token
            drive_access_tokens[recipient]['expiry'] = expiry
            assign_permission(file_id, email, recipient)